1.DFS
初始化注册频点到逻辑；
主节点：
同步状态下生效，在空闲位置获取最佳频点；

1.1.在时隙表中锁定出一片至少6个时隙的空闲区域作为切频时隙位置，如果没有则不切频；
切频流程：每个时隙依次执行1.2~1.7;
1.2.设置增益值，配置增益并切换到检测频点；
1.3.关闭切频寄存器；
1.4.等待状态；
1.5.如果切频成功标识置位，则切换到新使用频点，如果没有置位则切回到原使用频点；
1.6.统计并保存检测频点下的dbfs，当所有频点都检测完后，更新切频索引；
1.7.当没有接收时，不更新切频索引；有接收时根据误码率以及更小的信噪比判断来更新切频索引；
1.8.1.5的切频成功标识与新使用频点在tx发射配置ID域后更新；

从节点：
未同步情况下，每隔4个帧长，扫描下一个频点，直到获取接收后，设置发射位置发射；从而实现同步；

2.AFS
初始化注册频点到逻辑；
主节点：
1、上电初始化之后，配置相同vga，每个频点循环多次计算平均接收功率；
2、获取最佳底噪位置，然后切换频点；

从节点：
1、未同步时不分配发射时隙；
2、未同步，则每隔4个帧长，切频到下一个频点，直到同步到主节点；

3.跳频
1、初始化根据频点最大最小值，切分出大量频点，并注册到逻辑；
2、根据可接入节点数，将1中的频点集合划分为二维表格，最后3个频点数值为最小、最大、默认频点，并且维护此3个频点组成默认频点表；
3、系统启动后，每当有发射或接收时隙变动，都会更新在此发射位置跳频时候的时隙位置偏移和位置跨帧标志；
4、内核维护切频计数，并通过ID域同步到其他节点；
5、发射位置发射携带跳频计数到ID域，发射完成后更新下一个跳频索引；
6、接收端接收同步获取ID域中跳频计数，更新该时隙位置的跳频计数，然后计算出下一跳频点索引；
7、当下一个帧周期时，收发节点都会在此时隙位置，根据3中计算的配置跳频位置，下发切频指令，从而完成收发端的同时跳频；
8、发射完或者接收完成后会配置频点到默认频点，以使得新接入节点的频点变为默认频点时可以接入到该节点中；
9、根据测试发现，同步需要两节点相同频点持续几个帧周期，否则同步不了，所以必须保留2中提到的默认频点表；
10、切频时切换一段时间的由大到小依次频点，然后再切换一段时间默认频点表；

4.AES加密
1、初始化读取AES加密密钥，通过系统调用配置到SM4；
2、发射时，将一定字节数据拷贝到加密备份区域；
3、往FPGA的buf写入数据前，将加密备份区数据加密到原位置；
4、接收端接收到FPGA的buf数据后，将原位置一定字节数据解密到加密备份区；
5、然后将加密备份区数据恢复到原位置后正常接收；

5.测距
2、每次1ms解调获取样点偏移量，统计整个接收ms长度，计算平均值，作为新的接收样点变化量；
3、记录两两节点之间，发射样点位置与接收样点位置信息；
4、实际测距原理为：根据A->B B->A，A节点发射到A节点接收样点值减去B节点接收到B节点发射样点值；
5、差值表示A到B和B到A空间传输损耗时间，然后根据光速计算得出距离；
6、将B接收A到发射样点差值与发射到下次接收A样点差值通过信令包传输出去；
7、A节点接收到后，可以通过5方式计算得出简易的测距；
8、也可以通过数学（加减）推导得出的乘法方式计算得出来一套测距数据；
8、其他节点会将计算得出的测距数据通过信令包传输到对齐节点；
9：对齐节点打印测距数据；

6.路由
1、路由设置首次指向自身跳数为0的路由数据，通过信令包传输到其他节点；
2、其他节点接收到该信令包后，将下一跳设置为信令包发送节点，跳数加1；
3、根据2新增路由信息按条件插入到本节点的路由表；
4、排除路由目的为自身节点的路由信息，遍历如果目的节点不存在，则将此路由插入路由表；
5、存在目的节点与下一跳节点一致的路由信息，跳数更小或者序列号（发端帧号）更新则更新跳数、链路故障告警信息，
	无故障更新超时自身帧号，无故障无告警更新序列号；
6、目的一致，下一跳不一致：
	原路由有故障，更新，
	原路由无故障无告警，新路由跳数更小则更新，
	原路由有告警，新路由跳数更小或一致的话更新，跳数大需要满足sn较新则更新；
7、链路告警切换路由的门限通过网页配置得出；
8、通过接收信噪比、发射功率差值、底噪差值模拟计算出对端接收信噪比用于与路由切换门限比较；
9、小于低门限链路告警切多跳，大于高门限切回单跳；

7.接收时隙
1、同步时获取接收时隙信息：接收时隙索引、接收位置样点、频偏、跳数置1，其他比如长度等从ID域获取，更新到接收表；
2、信令包携带接收表发送，其他节点接收后将跳数置为2按条件更新到接收表中；
3、检验发射接收冲突，接收节点ID更大，更新发射冲突计数；
4、3中本节点ID更大，发射冲突计数快速叠加，冲突清理后将此接收添加到接收表；
5、校验接收与接收冲突，新接收节点ID更大则忽略，新接收节点ID更小则接收冲突计数快速叠加；
6、接收冲突，新接收ID更小，去掉原接收，更新新接收；
7、判断接收节点ID一致，新跳数更小或者跳数一致信令包计数更新则做如下处理：
	当：接收样点偏差超限、频偏偏差超限并且存在持续误码、时域不一致（每次新的时钟域ID对齐有一个新的时域），
	去掉原接收，更新新接收，保留原接收增益；
	否则：如果长度或位置有改变则更新到内核刷新接收，更新：长度、对齐id、发射位置、对齐计数、信令包计数、超时帧号、跳数；
8、如果更新完后与发射冲突。并且接收节点ID更小则去掉此发射；

8.流量统计
1、内核获取skb队列对应skb数据长度，标记索引；
2、计数到达1s后计算流量，字节数*8；
3、将流量计入到历史统计流量中，并计算平均流量；
4、当与平均流量差值大于扩充时隙资源流量的75%后更新流量为当前流量；
5、当比平均流量大50%时，或者当前流量小于时隙流量75%更新为当前流量；
6、否则使用平均流量；

9.底噪检测
1、配置固定增益，根据数字功率计算得出底噪；
2、调整增益，重新计算底噪，循环获取2s；
3、将数据组成数组发送到网页显示；

10.频点扫描
1、配置增益，配置频点，根据增益和数字功率计算得出底噪；
2、切换多个频点，计算得出每个频点的平均底噪；
3、循环两次后将数据推送给网页显示；

11.增益配置
1、每个大帧根据期望数字功率计算得出底噪和接收位置的增益；
2、当增益改变后，通过增益计算出寄存器配置，将数据写入到该接收的表中，并下发到内核；
3、内核在接收起始位置提前1个时隙下发接收增益，或根据时延样点提前2个时隙下发；
4、在接收末尾提前1个时隙下发底噪增益；

12.时隙划分
1、根据窄带时隙表划分时隙，如果冲突重新获取空闲时隙；
2、宽带时隙分配，根据流量获取需要的时隙数；
3、如果需要数超过最大宽时隙数，删除所有宽带，校验占用，获取空闲时隙全部分配；
4、如果需求数没有超限，获取当前占用时隙位置数组和个数；
5、根据需要与已占用个数比较：
	一致返回，
	需求变少，删除多余占用，
	需求变多，获取空闲重新分配；
6、在3和4之间，切换做缓冲，持续2s保持需要切换到另一种状态，再做切换，防止振荡；

13.串口
1、从config读取配置，包括串口类型，串口下配置的socket的本地端口，目的ip和端口；
2、初始化注册，配置串口波动率等硬件属性；
3、建立本地socket，如果tcp还需要建立连接；
4、将设置socket连接的本地端口下发内核作为qos判断标准；
5、循环读取串口数据，存入buf；
6、根据不同协议处理socket，转发数据；
7、tcp客户端判断socket连接是否正常，
	如果有串口数据则将数据写入socket发送buf，根据返回值，如果写入失败重新连接，返回值0缓冲区满做处理；
	读取socket数据写入串口，如果异常重新连接，如果对端关闭则清理客户端sock；
8、tcp服务端通过select多路IO复用，从注册的读取写入集合中获取连接sock：
	串口有数据且需要写入时写入，有数据可读时读取并发送到串口；
9、udp/组播接收数据发往串口，串口有数据发往sock；

14.电调
1、通过判断温度在哪个定标的电调区间，去对应电调值；
2、配置电调值调整以满足发射需求，电调是用来控制功放；

15.温补
1、通过判断温度在哪个定标的接收温补值区间，去对应接收温补值；
2、接收温补值用于计算底噪和接收功率；

16.Web网页
1、网页通过启动boa服务器作为网页服务端；
2、boa需要配置boa.conf指定web网页目录和其他配置；
3、通过json格式实现客户端与服务端数据交互；
4、通过websocket实现客户端与服务端连接；
5、初始化注册上下文，上下文包含回调协议函数；
6、回调函数包含连接建立、收到客户端数据、可写时、连接关闭等；
7、主要处理在收到客户端数据后执行客户端指令，当需要写时调用接收置为可写；
8、初始化sock用于节点间数据获取；

17.Arp本地化
1、此处arp为节点与ip之间的寻址；
2、表中包含超时时间，超时清理；
3、有区分节点ip和节点下挂设备ip；
4、网口接收到报文，更新/添加源ip到本节点下挂ip；
5、如果存在其他节点或节点下挂ip与此ip一致，则删除其他ip信息；
6、判断目的ip是否在表中，如果不在，则构造一个arp探测包发送并去除此包；
7、空口接收数据更新表：
	判断此空口包发送源端为协议栈还是网口，有协议栈发起并且节点ID和ip一致更新超时时间，
	有网口发起并且节点ID和下挂ip一致更新超时时间；
8、校验此ip是否在其他位置存在，存在则将其置为false；
9、如果id存在ip不存在，通过发起协议栈还是网口将其填充到对应的节点或下挂表中；
9、id和ip都不存在，通过发起协议栈还是网口将其填充到对应的节点或下挂表中；

18.日志处理
1、初始化创建日志文件；
2、打印时，将数据通过va_start等接口函数写入到buf中，并计数；
3、当检测到写入标志时将buf中数据写入到文件中，当写入字节超过限值后刷新文件；
4、后台通过tail -f获取实时写入的日志；

19.数据发送
1、判断快要到达发射位置，提前4个时隙准备数据；
2、如果有信令包，组信令包，组完还有空余组数据包，没有信令包只组数据包；
3、信令包填写发送长度，是否分段，整包索引，crc校验，以用于分段重组；
4、数据包通过系统调用从skb缓存队列中获取数据，填充必要头信息；
5、将数据写到fpga的buf中，并配置发射寄存器；
6、然后去使能发射寄存器，最后配置ID域数据到寄存器；

20.数据接收
1、同步后或者根据接收表下发接收解调指令；
2、fpga会有解调有效置位，当解调有效后判断crc有效后从fpga的buf读取数据，读取之前fifo地址复位；
3、将数据传回用户态，判断数据类型，校验crc长度等，如果包含信令包则处理；
4、处理接受信令包，处理分片重组，数据包传递到系统调用处理；
5、系统调用接收到数据后，判断有效性，处理分片重组，根据长度索引等组成新的skb包；
6、根据需要转发此skb包；

21.Crc校验
1、8位crc检验，主要通过异或算法，将一段数据放入计算；
2、对比收发计算的结果值是否一致；

22.2.接收
1、第一次接收校验ID域数据，获取发射端信息：长度、时域、信令包计数，并从每个时隙寄存器中获取开始位置、频偏，依照这些数据新建接收结构；
2、校验此接收在一定范围内是否有重叠，如果没有，则直接下发解调参数；
3、如果有的话，则持续监测多次后依然存在则将此接收推送到接收表处理；
4、第二次接收校验ID域数据，在第一次的后一个时隙，校验并获取节点ID、发射位置、时钟对齐ID、时钟计数，并执行类似3的处理流程；
5、如果有切频信息或跳频信息，处理；
6、将此接收信息推送到接收表中，更新超时帧号，设置跳数为1；


25.待补充
